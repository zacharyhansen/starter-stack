{"version":3,"sources":["../../src/view/view.service.ts"],"sourcesContent":["import { Inject, Injectable, Logger } from '@nestjs/common';\nimport { sql } from 'kysely';\nimport type { FoundationRole } from 'kysely-codegen';\n\nimport { Database, type TDatabase } from '~/database/database';\nimport { QueryService } from '~/query/query.service';\n\nexport interface ColumnEnabledRecord {\n  column_name: string;\n  is_primary_key?: boolean | null;\n  [key: string]: boolean | string | null | undefined;\n}\n\n@Injectable()\nexport class ViewService {\n  private readonly logger = new Logger(ViewService.name);\n\n  constructor(\n    @Inject(Database) private readonly database: Database,\n    private readonly queryService: QueryService\n  ) {}\n\n  async mutateViewsForRoles({\n    columnEnabledRecords,\n    name,\n  }: {\n    columnEnabledRecords: ColumnEnabledRecord[];\n    /** The name of the root view that all these child ones are created from */\n    name: string;\n  }) {\n    // Get the current roles in the system\n    const roles = await this.database\n      .withSchema('foundation')\n      .selectFrom('role')\n      .selectAll()\n      .execute();\n\n    const roleColumns = new Map<string, Record<string, boolean>>(\n      roles.map(role => [role.slug, {}])\n    );\n\n    // Loop over the records per column and build the result per role into roleColumns\n    for (const record of columnEnabledRecords) {\n      for (const role of roles) {\n        const atLeastOneColumnEnabledForRole = columnEnabledRecords.some(\n          record => Boolean(record[role.slug])\n        );\n        roleColumns.set(role.slug, {\n          ...roleColumns.get(role.slug),\n          // See if the column is enabled for the role\n          [record.column_name]: Boolean(\n            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n            record[role.slug] ||\n              // Auto add primary key if any column is enabled\n              (record.is_primary_key && atLeastOneColumnEnabledForRole)\n          ),\n        });\n      }\n    }\n\n    // For now we are going to drop and recreate - create and replace has potential conflicts via column renaming\n    // Possible in the future to do create and replace\n    await this.database.transaction().execute(async trx => {\n      const viewsToUpsert: string[] = [];\n      const viewsToDelete: string[] = [];\n\n      await Promise.all(\n        roles.map(async role => {\n          const viewName = ViewService.viewName({ name, role });\n          // first drop the view for each role\n          const columns: string[] = Object.entries(\n            roleColumns.get(role.slug) ?? []\n          )\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            .filter(([_key, value]) => value)\n            .map(([key]) => key);\n\n          await trx\n            .withSchema('foundation')\n            .schema.dropView(viewName)\n            .ifExists()\n            .execute();\n\n          // Then create it if there are columns\n          if (columns.length > 0) {\n            await trx\n              .withSchema('foundation')\n              .schema.createView(viewName)\n              .orReplace()\n              .as(\n                // @ts-expect-error Build the view name\n                this.database.selectFrom(name).select(columns)\n              )\n              .execute();\n            viewsToUpsert.push(viewName);\n          } else {\n            viewsToDelete.push(viewName);\n          }\n        })\n      );\n\n      // Now that we created/deleted the views in the DB we want to create DB records of the views / columns\n      // We do this to bridge the gap between postgres information tables / schemas and our application tables\n      // It may be possible to do this within information_schema but in order to store\n      // application meta data etc. about views we move the records into the customer scope\n\n      // Remove all records of the views that were deleted\n      await trx\n        .deleteFrom('q_view')\n        .where('name', 'in', viewsToDelete)\n        .execute();\n\n      const rootView = await trx\n        .selectFrom('pg_views')\n        .select(['schemaname', 'viewname', 'definition']) // Add other columns as needed\n        .where('viewname', '=', ViewService.viewRootName({ name }))\n        .where('schemaname', '=', 'foundation')\n        .execute();\n\n      const rootFields = await this.queryService.execute({\n        query:\n          sql`${rootView[0]?.definition.replace(';', '')} LIMIT 1;`.compile(\n            trx\n          ),\n      });\n\n      this.logger.log({ rootFields: rootFields.fields });\n\n      // Get the info we need to upsert the views that were updated or created\n      const viewsResults = await Promise.all(\n        viewsToUpsert.map(view =>\n          this.queryService.execute({\n            query: sql`select * from ${view} limit 1;`.compile(trx),\n          })\n        )\n      );\n\n      // Upsert the records into our tables\n      // const viewColumns = viewsResults.flatMap((result, viewIndex) =>\n      //   result.fields.map(field => {\n      //     return {\n      //       ...field,\n      //       view: viewsToUpsert[i],\n      //     };\n      //   })\n      // );\n    });\n\n    const allViews = roles.map(role => ViewService.viewName({ role, name }));\n\n    const columnResults = Promise.all(\n      allViews.map(view =>\n        this.queryService.execute({\n          query: sql`select * from ${view} limit 1;`.compile(this.database),\n        })\n      )\n    );\n\n    // await this.database.transaction().execute(async trx => {\n    return 'ok';\n  }\n\n  async columnsByRoleView({ name }: { name: string }) {\n    // Get the current roles in the system\n    const roles = await this.database\n      .withSchema('foundation')\n      .selectFrom('role')\n      .selectAll()\n      .execute();\n\n    // Try and find views for those roles if they exist\n    const allRoleViews = await Promise.allSettled(\n      roles.map(\n        async role =>\n          await this.database\n            .withSchema('foundation')\n            .selectFrom(ViewService.viewName({ name, role }))\n            .selectAll()\n            .execute()\n      )\n    );\n\n    // Get the superset of columns based on the master view of this data set/model\n    const masterView = await this.database\n      .withSchema('foundation')\n      .selectFrom('schema_columns as view')\n      // @ts-expect-error IDK why this is throwing but it works fine\n      .select([\n        'view.table_name',\n        'view.column_name',\n        'view.data_type',\n        'view.character_maximum_length',\n        'view.column_default',\n        'view.is_updatable',\n        'view.is_generated',\n        'view.generation_expression',\n        'source_table.is_nullable',\n        'source_table.is_primary_key',\n        'source_table.is_unique',\n        'source_table.foreign_table',\n      ])\n      .leftJoin('schema_columns as source_table', join =>\n        join\n          .onRef('view.column_name', '=', 'source_table.column_name')\n          .on('source_table.table_name', '=', name)\n      )\n      .where('view.table_name', '=', name)\n      .execute();\n\n    // Create a map for easy access of pssoible role to possible view (if it exists)\n    const roleViewMap = new Map(\n      roles.map((role, index) => [role.slug, allRoleViews[index]])\n    );\n\n    // Merge the superset records from the master view so that we get a column per role of whether a view exists for the role\n    // and has the column referenced in the master view\n    const merged = masterView.map(row => ({\n      ...row,\n      // eslint-disable-next-line unicorn/no-array-reduce\n      ...roles.reduce((accumulator, role) => {\n        const viewResult = roleViewMap.get(role.slug);\n        return {\n          ...accumulator,\n          [role.slug]:\n            viewResult?.status === 'fulfilled'\n              ? // @ts-expect-error Cant type the column name since who knows if it exists or not\n                Boolean(viewResult.value.some(v => Boolean(v[row.column_name])))\n              : false,\n        };\n      }, {}),\n    }));\n\n    return merged;\n  }\n\n  /** Deterministic name of the view based on the role and source view */\n  private static viewName({\n    name,\n    role,\n  }: {\n    name: string;\n    role: FoundationRole;\n  }): keyof TDatabase {\n    return `q_${name}__${role.slug}` as keyof TDatabase;\n  }\n\n  /** Deterministic name of the root view that role vq_view's are created from */\n  private static viewRootName({ name }: { name: string }): keyof TDatabase {\n    return `q_${name}` as keyof TDatabase;\n  }\n}\n"],"names":["ViewService","constructor","database","queryService","logger","Logger","name","mutateViewsForRoles","columnEnabledRecords","roles","withSchema","selectFrom","selectAll","execute","roleColumns","Map","map","role","slug","record","atLeastOneColumnEnabledForRole","some","Boolean","set","get","column_name","is_primary_key","transaction","trx","viewsToUpsert","viewsToDelete","Promise","all","viewName","columns","Object","entries","filter","_key","value","key","schema","dropView","ifExists","length","createView","orReplace","as","select","push","deleteFrom","where","rootView","viewRootName","rootFields","query","sql","definition","replace","compile","log","fields","viewsResults","view","allViews","columnResults","columnsByRoleView","allRoleViews","allSettled","masterView","leftJoin","join","onRef","on","roleViewMap","index","merged","row","reduce","accumulator","viewResult","status","v"],"mappings":"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"}